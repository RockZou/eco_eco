<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BestHTTP</name>
    </assembly>
    <members>
        <member name="T:BestHTTP.Cookies.Cookie">
            <summary>
            The Cookie implementation based on RFC 6265(http://tools.ietf.org/html/rfc6265).
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.Cookie.GuessSize">
            <summary>
            Guess the storage size of the cookie.
            </summary>
            <returns></returns>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Name">
            <summary>
            The name of the cookie.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Value">
            <summary>
            The value of the cookie.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Date">
            <summary>
            The Data when the Cookie is registered.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.LastAccess">
            <summary>
            When this Cookie last used in a request.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Expires">
            <summary>
            The Expires attribute indicates the maximum lifetime of the cookie, represented as the date and time at which the cookie expires. 
            The user agent is not required to retain the cookie until the specified date has passed. 
            In fact, user agents often evict cookies due to memory pressure or privacy concerns.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.MaxAge">
            <summary>
            The Max-Age attribute indicates the maximum lifetime of the cookie, represented as the number of seconds until the cookie expires. 
            The user agent is not required to retain the cookie for the specified duration.
            In fact, user agents often evict cookies due to memory pressure or privacy concerns.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.IsSession">
            <summary>
            If a cookie has neither the Max-Age nor the Expires attribute, the user agent will retain the cookie until "the current session is over".
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Domain">
            <summary>
            The Domain attribute specifies those hosts to which the cookie will be sent.
            For example, if the value of the Domain attribute is "example.com", the user agent will include the cookie
            in the Cookie header when making HTTP requests to example.com, www.example.com, and www.corp.example.com.
            If the server omits the Domain attribute, the user agent will return the cookie only to the origin server.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Path">
            <summary>
            The scope of each cookie is limited to a set of paths, controlled by the Path attribute.
            If the server omits the Path attribute, the user agent will use the "directory" of the request-uri's path component as the default value.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.IsSecure">
            <summary>
            The Secure attribute limits the scope of the cookie to "secure" channels (where "secure" is defined by the user agent).
            When a cookie has the Secure attribute, the user agent will include the cookie in an HTTP request only if the request is 
            transmitted over a secure channel (typically HTTP over Transport Layer Security (TLS)).
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.IsHttpOnly">
            <summary>
            The HttpOnly attribute limits the scope of the cookie to HTTP requests.
            In particular, the attribute instructs the user agent to omit the cookie when providing access to
            cookies via "non-HTTP" APIs (such as a web browser API that exposes cookies to scripts).
            </summary>
        </member>
        <member name="T:BestHTTP.Cookies.CookieJar">
            <summary>
            The Cookie Jar implementation based on RFC 6265(http://tools.ietf.org/html/rfc6265).
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Maintain">
            <summary>
            Deletes all expired or 'old' cookies, and will keep the sum size of cookies under the given size.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Persist">
            <summary>
            Saves the Cookie Jar to a file.
            </summary>
            <remarks>Not implemented under Unity WebPlayer</remarks>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Load">
            <summary>
            Load previously persisted cooki library from the file.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Get(System.Uri)">
            <summary>
            Returns all Cookies that corresponds to the given Uri.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Clear">
            <summary>
            Deletes all cookies from the Jar.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Clear(System.TimeSpan)">
            <summary>
            Removes cookies that older than the given parameter.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Clear(System.String)">
            <summary>
            Removes cookies that matches to the given domain.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Find(BestHTTP.Cookies.Cookie,System.Int32@)">
            <summary>
            Find and return a Cookie and his index in the list.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZTree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="T:BestHTTP.Extensions.HeartbeatManager">
            <summary>
            A manager class that can handle subscribing and unsubscribeing in the same update.
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPFieldData">
            <summary>
            This class represents a HTTP Form's field.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Name">
            <summary>
            The form's field.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.FileName">
            <summary>
            Filename of the field. Optional.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.MimeType">
            <summary>
            Mime-type of the field. Optional
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Encoding">
            <summary>
            Encoding of the data. Optional
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Text">
            <summary>
            The field's textual data.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Binary">
            <summary>
            The field's binary data.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Payload">
            <summary>
            Will return with the binary data, or if it's not present the textual data will be decoded to binary.
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPFormBase">
            <summary>
            Base class of a concrete implementation. Don't use it to create a form, use instead one of the already wrote implementation(HTTPMultiPartForm, HTTPUrlEncodedForm), or create a new one by inheriting from this base class.
            </summary>
        </member>
        <member name="M:BestHTTP.Forms.HTTPFormBase.CopyFrom(BestHTTP.Forms.HTTPFormBase)">
            <summary>
            It should 'clone' all the data from the given HTTPFormBase object.
            Called after the form-implementation created.
            </summary>
        </member>
        <member name="M:BestHTTP.Forms.HTTPFormBase.PrepareRequest(BestHTTP.HTTPRequest)">
            <summary>
            Prepares the request to sending a form. It should set only the headers.
            </summary>
        </member>
        <member name="M:BestHTTP.Forms.HTTPFormBase.GetData">
            <summary>
            Prepares and returns with the form's raw data.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.Fields">
            <summary>
            A list that holds the form's fields.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.IsEmpty">
            <summary>
            Returns true if the Fields has no element.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.IsChanged">
            <summary>
            True if new fields has been added to our list.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.HasBinary">
            <summary>
            True if there are at least one form-field with binary data.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.HasLongValue">
            <summary>
            True if there are at least one form-field with a long textual data.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPFormUsage.Automatic">
            <summary>
            The plugin will try to choose the best form sending method.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPFormUsage.UrlEncoded">
            <summary>
            The plugin will use the Url-Encoded form sending.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPFormUsage.Multipart">
            <summary>
            The plugin will use the Multipart form sending.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPFormUsage.Unity">
            <summary>
            The legacy, Unity-based form sending.
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPMultiPartForm">
            <summary>
            A HTTP Form implementation to send textual and binary values.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPMultiPartForm.Boundary">
            <summary>
            A random boundary generated in the constructor.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPMultiPartForm.CachedData">
            <summary>
            
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPUrlEncodedForm">
            <summary>
            A HTTP Form implementation to send textual values.
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.UnityForm">
            <summary>
            For backward compatibility.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.Address">
            <summary>
            Address of the proxy server. It has to be in the http://proxyaddress:port form.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.Credentials">
            <summary>
            Credentials of the proxy
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.IsTransparent">
            <summary>
            True if the proxy can act as a transparent proxy
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.SendWholeUri">
            <summary>
            Some non-transparent proxies are except only the path and query of the request uri. Default value is true
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.NonTransparentForHTTPS">
            <summary>
            Regardless of the value of IsTransparent, for secure protocols(HTTPS://, WSS://) the plugin will use the proxy as an explicit proxy(will issue a CONNECT request to the proxy)
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPRequestStates">
            <summary>
            Possible logical states of a HTTTPRequest object.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Initial">
            <summary>
            Initial status of a request. No callback will be called with this status.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Queued">
            <summary>
            Waiting in a queue to be processed. No callback will be called with this status.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Processing">
            <summary>
            Processing of the request started. In this state the client will send the request, and parse the response. No callback will be called with this status.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Finished">
            <summary>
            The request finished without problem. Parsing the response done, the result can be used. The user defined callback will be called with a valid response object. The request’s Exception property will be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Error">
            <summary>
            The request finished with an unexpected error. The user defined callback will be called with a null response object. The request's Exception property may contain more info about the error, but it can be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Aborted">
            <summary>
            The request aborted by the client(HTTPRequest’s Abort() function). The user defined callback will be called with a null response. The request’s Exception property will be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.ConnectionTimedOut">
            <summary>
            Connecting to the server timed out. The user defined callback will be called with a null response. The request’s Exception property will be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.TimedOut">
            <summary>
            The request didn't finished in the given time. The user defined callback will be called with a null response. The request’s Exception property will be null.
            </summary>
        </member>
        <member name="T:BestHTTP.JSON.Json">
             <summary>
             Based on the download from http://techblog.procurios.nl/k/news/view/14605/14863/how-do-i-write-my-own-parser-%28for-json%29.html
             This class encodes and decodes JSON strings.
             Spec. details, see http://www.json.org/
            
             JSON uses Arrays and Objects. These correspond here to the datatypes List and Dictionary.
             All numbers are parsed to doubles.
             </summary>
        </member>
        <member name="M:BestHTTP.JSON.Json.Decode(System.String)">
            <summary>
            Parses the string json into a value
            </summary>
            <param name="json">A JSON string.</param>
            <returns>A List, a Dictionary, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:BestHTTP.JSON.Json.Decode(System.String,System.Boolean@)">
            <summary>
            Parses the string json into a value; and fills 'success' with the successfullness of the parse.
            </summary>
            <param name="json">A JSON string.</param>
            <param name="success">Successful parse?</param>
            <returns>A List, a Dictionary, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:BestHTTP.JSON.Json.Encode(System.Object)">
            <summary>
            Converts a Dictionary / List object into a JSON string
            </summary>
            <param name="json">A Dictionary / List</param>
            <returns>A JSON encoded string, or null if object 'json' is not serializable</returns>
        </member>
        <member name="T:BestHTTP.Logger.DefaultLogger">
            <summary>
            A basic logger implementation to be able to log intelligently additional informations about the plugin's internal mechanism.
            </summary>
        </member>
        <member name="P:BestHTTP.Logger.ILogger.Level">
            <summary>
            The minimum severity to log
            </summary>
        </member>
        <member name="T:BestHTTP.Logger.Loglevels">
            <summary>
            Available logging levels.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.All">
            <summary>
            All message will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Information">
            <summary>
            Only Informations and above will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Warning">
            <summary>
            Only Warnings and above will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Error">
            <summary>
            Only Errors and above will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Exception">
            <summary>
            Only Exceptions will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.None">
            <summary>
            No logging will be occur.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPResponse">
            <summary>
            
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPResponse.dataAsText">
            <summary>
            Cached, converted data.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPResponse.texture">
            <summary>
            Cached converted data.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetHeaderValues(System.String)">
            <summary>
            Returns the list of values that received from the server for the given header name.
            <remarks>Remarks: All headers converted to lowercase while reading the response.</remarks>
            </summary>
            <param name="name">Name of the header</param>
            <returns>If no header found with the given name or there are no values in the list (eg. Count == 0) returns null.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetFirstHeaderValue(System.String)">
            <summary>
            Returns the first value in the header list or null if there are no header or value.
            </summary>
            <param name="name">Name of the header</param>
            <returns>If no header found with the given name or there are no values in the list (eg. Count == 0) returns null.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.HasHeaderWithValue(System.String,System.String)">
            <summary>
            Checks if there is a header with the given name and value.
            </summary>
            <param name="headerName">Name of the header.</param>
            <param name="value"></param>
            <returns>Returns true if there is a header with the given name and value.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.HasHeader(System.String)">
            <summary>
            Checks if there is a header with the given name.
            </summary>
            <param name="headerName">Name of the header.</param>
            <returns>Returns true if there is a header with the given name.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetRange">
            <summary>
            Parses the 'Content-Range' header's value and returns a HTTPRange object.
            </summary>
            <remarks>If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist.
            (Normally, this means return a 200 response containing the full entity). In this case becouse of there are no 'Content-Range' header, this function will return null!</remarks>
            <returns>Returns null if no 'Content-Range' header found.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.FeedStreamFragment(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add data to the fragments list.
            </summary>
            <param name="buffer">The buffer to be added.</param>
            <param name="pos">The position where we start copy the data.</param>
            <param name="length">How many data we want to copy.</param>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetStreamedFragments">
            <summary>
            If streaming is used, then every time this callback function called we can use this function to
             retrive the downloaded and buffered data. The returned list can be null, if there is no data yet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.Dispose">
            <summary>
            IDisposable implementation.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.StatusCode">
            <summary>
            The status code that sent from the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsSuccess">
            <summary>
            Returns true if the status code is in the range of [200..300[ or 304 (Not Modified)
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.Message">
            <summary>
            The message that sent along with the StatusCode from the server. You can check it for errors from the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsStreamed">
            <summary>
            True if it's a streamed response.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsStreamingFinished">
            <summary>
            True if the streaming is finished, and no more fragments are coming.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsFromCache">
            <summary>
            Indicates that the response body is read from the cache.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.Headers">
            <summary>
            The headers that sent from the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.Data">
            <summary>
            The data that donwloaded from the server. All Transfer and Content encodings decoded if any(eg. chunked, gzip, deflate).
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsUpgraded">
            <summary>
            The normal HTTP protocol is upgraded to an other.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.Cookies">
            <summary>
            The cookies that the server sent to the client.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.DataAsText">
            <summary>
            The data converted to an UTF8 string.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.DataAsTexture2D">
            <summary>
            The data loaded to a Texture2D.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.TransportEventTypes">
            <summary>
            Possible event types on the transport level.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.SocketIOEventTypes">
            <summary>
            Event types of the SocketIO protocol.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Connect">
            <summary>
            Connect to a napespace, or we connected to a namespace
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Disconnect">
            <summary>
            Disconnect a namespace, or we disconnected from a namespace.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Event">
            <summary>
            A general event. The event's name is in the payload.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Ack">
            <summary>
            Acknowledgement of an event.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Error">
            <summary>
            Error sent by the server, or by the plugin
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.BinaryEvent">
            <summary>
            A general event with binary attached to the packet. The event's name is in the payload.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.BinaryAck">
            <summary>
            Acknowledgement of a binary event.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.SocketIOErrors">
            <summary>
            Possible error codes that the SocketIO server can send.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.UnknownTransport">
            <summary>
            Transport unknown
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.UnknownSid">
            <summary>
            Session ID unknown
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.BadHandshakeMethod">
            <summary>
            Bad handshake method
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.BadRequest">
            <summary>
            Bad request
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.Internal">
            <summary>
            Plugin internal error!
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.User">
            <summary>
            Exceptions that caught by the plugin but raised in a user code.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Events.EventDescriptor">
            <summary>
            A class to describe an event, and its metadatas.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Events.EventDescriptor.CallbackArray">
            <summary>
            Cache an array on a hot-path.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventDescriptor.#ctor(System.Boolean,System.Boolean,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Constructor to create an EventDescriptor instance and set the meta-datas.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventDescriptor.Call(BestHTTP.SocketIO.Socket,BestHTTP.SocketIO.Packet,System.Object[])">
            <summary>
            Will call the callback delegates with the given parameters and remove the callbacks if this descriptor marked with a true OnlyOnce property.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventDescriptor.Callbacks">
            <summary>
            List of callback delegates.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventDescriptor.OnlyOnce">
            <summary>
            If this property is true, callbacks are removed automatically after the event dispatch.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventDescriptor.AutoDecodePayload">
            <summary>
            If this property is true, the dispatching packet's Payload will be decoded using the Manager's Encoder.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Events.EventNames">
            <summary>
            Helper class to provide functions to an easy Enum->string conversation of the transport and SocketIO evenet types.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventNames.IsBlacklisted(System.String)">
            <summary>
            Checks an event name whether it's blacklisted or not.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Events.EventTable">
            <summary>
            This class helps keep track and maintain EventDescriptor instances and dispatching packets to the right delegates.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Events.EventTable.Table">
            <summary>
            The 'EventName -> List of events' mapping.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.#ctor(BestHTTP.SocketIO.Socket)">
            <summary>
            Constructor to create an instance and bind it to a socket.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Register(System.String,BestHTTP.SocketIO.Events.SocketIOCallback,System.Boolean,System.Boolean)">
            <summary>
            Register a callback to a name with the given metadata.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Unregister(System.String)">
            <summary>
            Removes all events that registered for the given name.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Unregister(System.String,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Call(System.String,BestHTTP.SocketIO.Packet,System.Object[])">
            <summary>
            Will call the delegates that associated to the given eventName.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Call(BestHTTP.SocketIO.Packet)">
            <summary>
            This function will get the eventName from the packet's Payload, and optionally will decode it from Json.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Clear">
            <summary>
            Remove all event -> delegate association.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.ShouldDecodePayload(System.String)">
            <summary>
            Returns true, if for the given event name there are at least one event that needs a decoded 
            </summary>
            <param name="eventName"></param>
            <returns></returns>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventTable.Socket">
            <summary>
            The Socket that this EventTable is bound to.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.HandshakeData">
            <summary>
            This class able to fill it's properties by starting a HTTP request and parsing its result. After a successfull response it will store the parsed data.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.HandshakeData.OnReceived">
            <summary>
            Event handler that called when the handshake data received and parsed successfully.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.HandshakeData.OnError">
            <summary>
            Event handler that called when an error happens.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.HandshakeData.Start">
            <summary>
            Internal function, this will start a regular GET request to the server to receive the handshake data.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.HandshakeData.Abort">
            <summary>
            Internal function to be able to abort the request if necessary.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.HandshakeData.OnHandshakeCallback(BestHTTP.HTTPRequest,BestHTTP.HTTPResponse)">
            <summary>
            Private event handler that called when the handshake request finishes.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.Sid">
            <summary>
            Session ID of this connection.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.Upgrades">
            <summary>
            List of possible updgrades.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.PingInterval">
            <summary>
            What interval we have to set a ping message.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.PingTimeout">
            <summary>
            What time have to pass without an answer to our ping request when we can consider the connection disconnected.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.Manager">
            <summary>
            The SocketManager instance that this handshake data is bound to.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.IManager">
            <summary>
            Interface to hide internal functions from the user by implementing it as an explicit interface.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.ISocket">
            <summary>
            Interface to hide internal functions from the user by implementing it as an explicit interface.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.JsonEncoders.DefaultJSonEncoder">
            <summary>
            The default IJsonEncoder implementation. It's uses the Json class from the BestHTTP.JSON namespace to encode and decode.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.JsonEncoders.IJsonEncoder">
            <summary>
            Interface to be able to write custom Json encoders/decoders.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.JsonEncoders.IJsonEncoder.Decode(System.String)">
            <summary>
            The Decode function must create a list of objects from the Json formatted string parameter. If the decoding fails, it should return null.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.JsonEncoders.IJsonEncoder.Encode(System.Collections.Generic.List{System.Object})">
            <summary>
            The Encode function must create a json formatted string from the parameter. If the encoding fails, it should return null.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.#ctor">
            <summary>
            Internal constructor. Don't use it directly!
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.#ctor(System.String)">
            <summary>
            Internal constructor. Don't use it directly!
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.#ctor(BestHTTP.SocketIO.TransportEventTypes,BestHTTP.SocketIO.SocketIOEventTypes,System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Internal constructor. Don't use it directly!
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.DecodeEventName">
            <summary>
            Will set and return with the EventName from the packet's Payload string.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.ReconstructAttachmentAsIndex">
            <summary>
            Will switch the "{'_placeholder':true,'num':X}" to a the index num X.
            </summary>
            <returns>True if successfully reconstructed, false otherwise.</returns>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.ReconstructAttachmentAsBase64">
            <summary>
            Will switch the "{'_placeholder':true,'num':X}" to a the data as a base64 encoded string.
            </summary>
            <returns>True if successfully reconstructed, false otherwise.</returns>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.Parse(System.String)">
            <summary>
            Parse the packet from a server sent textual data. The Payload will be the raw json string.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.Encode">
            <summary>
            Encodes this packet to a Socket.IO formatted string.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.EncodeBinary">
            <summary>
            Encodes this packet to a Socket.IO formatted byte array.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.AddAttachmentFromServer(System.Byte[],System.Boolean)">
            <summary>
            Will add the byte[] that the server sent to the attachments list.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.EncodeData(System.Byte[],BestHTTP.SocketIO.Packet.PayloadTypes,System.Byte[])">
            <summary>
            Encodes a byte array to a Socket.IO binary encoded message
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.PlaceholderReplacer(System.Action{System.String,System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            Searches for the "{'_placeholder':true,'num':X}" string, and will call the given action to modify the PayLoad
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.ToString">
            <summary>
            Returns with the Payload of this packet.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.Clone">
            <summary>
            Will clone this packet to an identical packet instance.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.TransportEvent">
            <summary>
            Event type of this packet on the transport layer.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.SocketIOEvent">
            <summary>
            The packet's type in the Socket.IO protocol.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.AttachmentCount">
            <summary>
            How many attachment should have this packet.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Id">
            <summary>
            The internal ack-id of this packet.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Namespace">
            <summary>
            The sender namespace's name.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Payload">
            <summary>
            The payload as a Json string.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.EventName">
            <summary>
            The decoded event name from the payload string.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Attachments">
            <summary>
            All binary data attached to this event.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.HasAllAttachment">
            <summary>
            Property to check whether all attachments are received to this packet.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.IsDecoded">
            <summary>
            True if it's already decoded. The DecodedArgs still can be null after the Decode call.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.DecodedArgs">
            <summary>
            The decoded arguments from the result of a Json string -> c# object convert.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Socket">
            <summary>
            This class represents a Socket.IO namespace.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Socket.AckCallbacks">
            <summary>
            A table to store acknowlegement callbacks associated to the given ids.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Socket.EventCallbacks">
            <summary>
            Tha callback table that helps this class to manage event subsciption and dispatching events.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Socket.arguments">
            <summary>
            Cached list to spare some GC alloc.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.#ctor(System.String,BestHTTP.SocketIO.SocketManager)">
            <summary>
            Internal constructor.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#Open">
            <summary>
            Internal function to start opening the socket.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Disconnect">
            <summary>
            Disconnects this socket/namespace.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#Disconnect(System.Boolean)">
            <summary>
            Disconnects this socket/namespace.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.On(System.String,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Register a callback for a given name
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off">
            <summary>
            Remove all callbacks for all events.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(System.String)">
            <summary>
            Removes all callbacks to the given event.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(BestHTTP.SocketIO.SocketIOEventTypes)">
            <summary>
            Removes all callbacks to the given event.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(System.String,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Remove the specified callback.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(BestHTTP.SocketIO.SocketIOEventTypes,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Remove the specified callback.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Last call of the OnPacket chain(Transport -> Manager -> Socket), we will dispatch the event if there is any callback
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#EmitEvent(BestHTTP.SocketIO.SocketIOEventTypes,System.Object[])">
            <summary>
            Emits an internal packet-less event to the user level.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#EmitEvent(System.String,System.Object[])">
            <summary>
            Emits an internal packet-less event to the user level.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.OnTransportOpen(BestHTTP.SocketIO.Socket,BestHTTP.SocketIO.Packet,System.Object[])">
            <summary>
            Called when a "connect" event received to the root namespace
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.Manager">
            <summary>
            The SocketManager instance that created this socket.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.Namespace">
            <summary>
            The namespace that this socket is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.IsOpen">
            <summary>
            True if the socket is connected and open to the server. False otherwise.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.AutoDecodePayload">
            <summary>
            While this property is True, the socket will decode the Packet's Payload data using the parent SocketManager's Encoder. You must set this property before any event subsciption! It's default value is True;
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.MinProtocolVersion">
            <summary>
            Supported Socket.IO protocol version
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.DefaultEncoder">
            <summary>
            The default Json encode/decoder that will be used to encode/decode the event arguments.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.Namespaces">
            <summary>
            Namespace name -> Socket mapping
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.Sockets">
            <summary>
            List of the sockets to able to iterate over them easily.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.OfflinePackets">
            <summary>
            List of unsent packets. Only instantiated when we have to use it.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.Poller">
            <summary>
            The poller transport. We will use this while the WebSocket upgrade didn't complete.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.LastHeartbeat">
            <summary>
            When we sent out the last heartbeat(Ping) message.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.LastPongReceived">
            <summary>
            When we received the last Pong message answering to our heartbeat(Ping) message.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.ReconnectAt">
            <summary>
            When we have to try to do a reconnect attempt
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.ConnectionStarted">
            <summary>
            When we started to connect to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.#ctor(System.Uri)">
            <summary>
            Constructor to create a SocketManager instance that will connect to the given uri.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.#ctor(System.Uri,BestHTTP.SocketIO.SocketOptions)">
            <summary>
            Constructor to create a SocketManager instance.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.GetSocket">
            <summary>
            Returns with the "/" namespace, the same as the Socket property.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.GetSocket(System.String)">
            <summary>
            Returns with the specified namespace
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#Remove(BestHTTP.SocketIO.Socket)">
            <summary>
            Internal function to remove a Socket instance from this manager.
            </summary>
            <param name="socket"></param>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.Open">
            <summary>
            This function will begin to open the Socket.IO connection by sending out the handshake request.
            If the Options' AutoConnect is true, it will be called automatically.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#Close(System.Boolean)">
            <summary>
            Closes this Socket.IO connection.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#TryToReconnect">
            <summary>
            Called from a ITransport implemetation when an error occures and we may have to try to reconnect.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.CreateTransports">
            <summary>
            Creates and starts opening/upgrading process of the transports.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#OnTransportConnected(BestHTTP.SocketIO.Transports.ITransport)">
            <summary>
            Called by transports when they are connected to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.SelectTransport">
            <summary>
            Select the best transport to send out packets.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.SendOfflinePackets">
            <summary>
            Will select the best transport and sends out all packets that are in the OfflinePackets list.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#SendPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Internal function that called from the Socket class. It will send out the packet instantly, or if no transport is available it will store
            the packet in the OfflinePackets list.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Called from the currently operating Transport. Will pass forward to the Socket that has to call the callbacks.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.EmitAll(System.String,System.Object[])">
            <summary>
            Sends an event to all available namespaces.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#EmitEvent(System.String,System.Object[])">
            <summary>
            Emits an internal packet-less event to the root namespace without creating it if it isn't exists yet.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#EmitEvent(BestHTTP.SocketIO.SocketIOEventTypes,System.Object[])">
            <summary>
            Emits an internal packet-less event to the root namespace without creating it if it isn't exists yet.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#Extensions#IHeartbeat#OnHeartbeatUpdate(System.TimeSpan)">
            <summary>
            Called from the HTTPManager's OnUpdate function every frame. It's main function is to send out heartbeat messages.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.State">
            <summary>
            The current state of this Socket.IO manager.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Options">
            <summary>
            The SocketOptions instance that this manager will use.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Uri">
            <summary>
            The Uri to the Socket.IO endpoint.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Handshake">
            <summary>
            The server sent and parsed Handshake data.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Transport">
            <summary>
            The currently used main transport instance.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.RequestCounter">
            <summary>
            The Request counter for request-based transports.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Socket">
            <summary>
            The root("/") Socket.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Item(System.String)">
            <summary>
            Indexer to access socket associated to the given namespace.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.ReconnectAttempts">
            <summary>
            How many reconnect attempts made.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Encoder">
            <summary>
            The JSon encoder that will be used to encode the sent data to json and decode the received json to an object list.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Timestamp">
            <summary>
            Timestamp support to the request based transports.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.NextAckId">
            <summary>
            Autoincrementing property to return Ack ids.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.PreviousState">
            <summary>
            Internal property to store the previous state of the manager.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.SocketManager.States">
            <summary>
            Possible states of a SocketManager instance.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Initial">
            <summary>
            Initial state of the SocketManager
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Closed">
            <summary>
            The SocketManager is closed, initiated by the user or by the server
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Opening">
            <summary>
            The SocketManager is currently opening.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Open">
            <summary>
            The SocketManager is open, events can be sent to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Reconnecting">
            <summary>
            An error occured, the SocketManager now trying to connect again to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketOptions.BuiltQueryParams">
            <summary>
            The cached value of the result of the BuildQueryParams() call.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketOptions.#ctor">
            <summary>
            Constructor, setting the default option values.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketOptions.BuildQueryParams">
            <summary>
            Builds the keys and values from the AdditionalQueryParams to an key=value form. If AdditionalQueryParams is null or empty, it will return an empty string.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.Reconnection">
            <summary>
            Whether to reconnect automatically after a disconnect (default true)
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.ReconnectionAttempts">
            <summary>
            Number of attempts before giving up (default Int.MaxValue)
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.ReconnectionDelay">
            <summary>
            How long to initially wait before attempting a new reconnection (default 1000ms).
            Affected by +/- RandomizationFactor, for example the default initial delay will be between 500ms to 1500ms.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.ReconnectionDelayMax">
            <summary>
            Maximum amount of time to wait between reconnections (default 5000ms).
            Each attempt increases the reconnection delay along with a randomization as above.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.RandomizationFactor">
            <summary>
            (default 0.5`), [0..1]
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.Timeout">
            <summary>
            Connection timeout before a connect_error and connect_timeout events are emitted (default 20000ms)
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.AutoConnect">
            <summary>
            By setting this false, you have to call SocketManager's Open() whenever you decide it's appropriate.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.AdditionalQueryParams">
            <summary>
            Additional query parameters that will be passed for the handsake uri. If the value is null, or an empty string it will be not appended to the query only the key.
            <remarks>The keys and values must be escaped properly, as the plugin will not escape these. </remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.QueryParamsOnlyForHandshake">
            <summary>
            If it's false, the parmateres in the AdditionalQueryParams will be passed for all http requests. Its default value is true.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Transports.TransportStates">
            <summary>
            Possible states of an ITransport implementation.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Connecting">
            <summary>
            The transport is connecting to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Opening">
            <summary>
            The transport is connected, and started the opening process.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Open">
            <summary>
            The transport is open, can send and receive packets.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Closed">
            <summary>
            The transport is closed.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Paused">
            <summary>
            The transport is paused.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Transports.ITransport">
            <summary>
            An interface that a Socket.IO transport must implement.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Open">
            <summary>
            Start open/upgrade the transport.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Poll">
            <summary>
            Do a poll for available messages on the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Send(BestHTTP.SocketIO.Packet)">
            <summary>
            Send a single packet to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Send(System.Collections.Generic.List{BestHTTP.SocketIO.Packet})">
            <summary>
            Send a list of packets to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Close">
            <summary>
            Close this transport.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Transports.ITransport.State">
            <summary>
            Current state of the transport
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Transports.ITransport.Manager">
            <summary>
            SocketManager instance that this transport is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Transports.ITransport.IsRequestInProgress">
            <summary>
            True if the transport is busy with sending messages.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.PollingTransport.LastRequest">
            <summary>
            The last POST request we sent to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.PollingTransport.PollRequest">
            <summary>
            Last GET request we sent to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.PollingTransport.PacketWithAttachment">
            <summary>
            The last packet with expected binary attachments
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.PollingTransport.Close">
            <summary>
            Closes the transport and cleans up resources.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.PollingTransport.OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Preprocessing and sending out packets to the manager.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.PollingTransport.ParseResponse(BestHTTP.HTTPResponse)">
            <summary>
            Will parse the response, and send out the parsed packets.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Transports.WebSocketTransport">
            <summary>
            A transport implementation that can communicate with a SocketIO server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Close">
            <summary>
            Closes the transport and cleans up resources.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Poll">
            <summary>
            Polling implementation. With WebSocket it's just a skeleton.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnOpen(BestHTTP.WebSocket.WebSocket)">
            <summary>
            WebSocket implementation OnOpen event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnMessage(BestHTTP.WebSocket.WebSocket,System.String)">
            <summary>
            WebSocket implementation OnMessage event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnBinary(BestHTTP.WebSocket.WebSocket,System.Byte[])">
            <summary>
            WebSocket implementation OnBinary event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnError(BestHTTP.WebSocket.WebSocket,System.Exception)">
            <summary>
            WebSocket implementation OnError event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnClosed(BestHTTP.WebSocket.WebSocket,System.UInt16,System.String)">
            <summary>
            WebSocket implementation OnClosed event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Send(BestHTTP.SocketIO.Packet)">
            <summary>
            A WebSocket implementation of the packet sending.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Send(System.Collections.Generic.List{BestHTTP.SocketIO.Packet})">
            <summary>
            A WebSocket implementation of the packet sending.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Will only process packets that need to upgrade. All other packets are passed to the Manager.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.Connections">
            <summary>
            Connection based statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.Cache">
            <summary>
            Caching based statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.Cookies">
            <summary>
            Cookie based statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.All">
            <summary>
            All statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.Connections">
            <summary>
            Number of HTTPConnection instances
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.ActiveConnections">
            <summary>
            Number of active connections. These connections are currently processing a request.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.FreeConnections">
            <summary>
            Number of free connections. These connections are finished with there requests and waiting for another request or to recycle.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.RecycledConnections">
            <summary>
            Number of recycled connections. These connections will be removed as soon as possible.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.RequestsInQueue">
            <summary>
            Number of requests that are waiting in the queue for a free connection.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CacheEntityCount">
            <summary>
            Number of cached responses.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CacheSize">
            <summary>
            Sum size of the cached responses in bytes.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CookieCount">
            <summary>
            Number of cookies in the Cookie Jar.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CookieJarSize">
            <summary>
            Sum size of the stored cookies in bytes.
            </summary>
        </member>
        <member name="T:BestHTTP.Caching.HTTPCacheFileInfo">
            <summary>
            Holds all metadata that need for efficient caching, so we don't need to touch the disk to load headers.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.Uri">
            <summary>
            The uri that this HTTPCacheFileInfo belongs to.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.LastAccess">
            <summary>
            The last access time to this cache entity. The date is in UTC.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.BodyLength">
            <summary>
            The length of the cache entity's body.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.ETag">
            <summary>
            ETag of the entity.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.LastModified">
            <summary>
            LastModified date of the entity.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.Expires">
            <summary>
            When the cache will expire.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.Age">
            <summary>
            The age that came with the response
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.MaxAge">
            <summary>
            Maximum how long the entry should served from the cache without revalidation.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.Date">
            <summary>
            The Date that came with the response.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.MustRevalidate">
            <summary>
            Indicates whether the entity must be revalidated with the server or can be serverd directly from the cache without touching the server.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.Received">
            <summary>
            The date and time when the HTTPResponse received.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.ConstructedPath">
            <summary>
            Cached path.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheMaintananceParams.DeleteOlder">
            <summary>
            Delete cache entries that accessed older then this value. If TimeSpan.FromSeconds(0) is used then all cache entries will be deleted. With TimeSpan.FromDays(2) entries that older then two days will be deleted.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheMaintananceParams.MaxCacheSize">
            <summary>
            If the cache is larger then the MaxCacheSize after the first maintanance step, then the maintanance job will forcedelete cache entries starting with the oldest last accessed one.
            </summary>
        </member>
        <member name="F:BestHTTP.Caching.HTTPCacheService.LibraryVersion">
            <summary>
            Library file-format versioning support
            </summary>
        </member>
        <member name="M:BestHTTP.Caching.HTTPCacheService.SetHeaders(BestHTTP.HTTPRequest)">
            <summary>
            Utility function to set the cache control headers according to the spec.: http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:BestHTTP.Caching.HTTPCacheService.IsCacheble(System.Uri,BestHTTP.HTTPMethods,BestHTTP.HTTPResponse)">
            <summary>
            Checks if the given response can be cached. http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
            </summary>
            <returns>Returns true if cacheable, false otherwise.</returns>
        </member>
        <member name="M:BestHTTP.Caching.HTTPCacheService.BeginClear">
            <summary>
            Deletes all cache entity. Non blocking.
            <remarks>Call it only if there no requests currently processed, becouse cache entries can be deleted while a server sends back a 304 result, so there will be no data to read from the cache!</remarks>
            </summary>
        </member>
        <member name="M:BestHTTP.Caching.HTTPCacheService.BeginMaintainence(BestHTTP.Caching.HTTPCacheMaintananceParams)">
            <summary>
            Deletes all expired cache entity.
            <remarks>Call it only if there no requests currently processed, becouse cache entries can be deleted while a server sends back a 304 result, so there will be no data to read from the cache!</remarks>
            </summary>
        </member>
        <member name="M:BestHTTP.Caching.HTTPCacheService.DeleteUnusedFiles">
            <summary>
            Deletes all files from the cache folder that isn't in the Library.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Crc.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name = "b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
              <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name = "b">the byte to include into the CRC.  </param>
            <param name = "n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name='reverseBits'>
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
              <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.#ctor(System.Int32,System.Boolean)">
             <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
             <param name='polynomial'>
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
             <param name='reverseBits'>
               specify true if the instance should reverse data bits.
             </param>
            
             <remarks>
               <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
             </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
              <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Crc.CrcCalculatorStream">
             <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read,
             or on all bytes written.
             </summary>
            
             <remarks>
             <para>
             This class can be used to verify the CRC of a ZipEntity when
             reading from a stream, or to calculate a CRC when writing to a
             stream.  The stream should be used to either read, or write, but
             not both.  If you intermix reads and writes, the results are not
             defined.
             </para>
            
             <para>
             This class is intended primarily for use internally by the
             DotNetZip library.
             </para>
             </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The default constructor.
            </summary>
            <remarks>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().  The stream uses the default CRC32
                algorithm, which implies a polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              The constructor allows the caller to specify how to handle the
              underlying stream at close.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close().
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean,BestHTTP.Decompression.Crc.CRC32)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close(), and the CRC32 instance to use.
            </summary>
            <remarks>
              <para>
                The stream uses the specified CRC32 instance, which allows the
                application to specify how the CRC gets calculated.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
            <param name="crc32">the CRC32 instance to use to calculate the CRC32</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeking is not supported on this stream. This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="value">N/A</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.Close">
            <summary>
            Closes the stream.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
               Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
               This is either the total number of bytes read, or the total number of
               bytes written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CrcCalculatorStream.Crc">
            <summary>
              Provides the current CRC for all blocks slurped in.
            </summary>
            <remarks>
              <para>
                The running total of the CRC is kept as data is written or read
                through the stream.  read this property after all reads or writes to
                get an accurate CRC for the entire stream.
              </para>
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CrcCalculatorStream.LeaveOpen">
            <summary>
              Indicates whether the underlying stream will be left open when the
              <c>CrcCalculatorStream</c> is Closed.
            </summary>
            <remarks>
              <para>
                Set this at any point before calling <see cref="M:BestHTTP.Decompression.Crc.CrcCalculatorStream.Close"/>.
              </para>
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CrcCalculatorStream.CanSeek">
            <summary>
              Indicates whether the stream supports seeking.
            </summary>
            <remarks>
              <para>
                Always returns false.
              </para>
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CrcCalculatorStream.Length">
            <summary>
              Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CrcCalculatorStream.Position">
            <summary>
              The getter for this property returns the total bytes read.
              If you use the setter, it will throw
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.DeflateStream">
             <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            
             <remarks>
            
             <para>
               The DeflateStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream"/>.  It adds DEFLATE compression or decompression to any
               stream.
             </para>
            
             <para>
               Using this stream, applications can compress or decompress data via stream
               <c>Read</c> and <c>Write</c> operations.  Either compresssion or decompression
               can occur through either reading or writing. The compression format used is
               DEFLATE, which is documented in <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
               Compressed Data Format Specification version 1.3.".
             </para>
            
             <para>
               This class is similar to <see cref="T:BestHTTP.Decompression.Zlib.ZlibStream"/>, except that
               <c>ZlibStream</c> adds the <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
               1950 - ZLIB</see> framing bytes to a compressed stream when compressing, or
               expects the RFC1950 framing bytes when decompressing. The <c>DeflateStream</c>
               does not.
             </para>
            
             </remarks>
            
             <seealso cref="T:BestHTTP.Decompression.Zlib.ZlibStream"/>
             <seealso cref="T:BestHTTP.Decompression.Zlib.GZipStream"/>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode)">
             <summary>
               Create a DeflateStream using the specified CompressionMode.
             </summary>
            
             <remarks>
               When mode is <c>CompressionMode.Compress</c>, the DeflateStream will use
               the default compression level. The "captive" stream will be closed when
               the DeflateStream is closed.
             </remarks>
            
             <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel)">
             <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.  The "captive" stream will be closed when the DeflateStream is
               closed.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses a DeflateStream to compress data from a file, and writes
               the compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress,
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified
               <c>CompressionMode</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compression.  Specify true for
               the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               The <c>DeflateStream</c> will use the default compression level.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the
               "captive" stream in other places in this documentation.
             </param>
            
             <param name="mode">
               Indicates whether the <c>DeflateStream</c> will compress or decompress.
             </param>
            
             <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                Application code won't call this code directly.  This method may be
                invoked in two distinct scenarios.  If disposing == true, the method
                has been called directly or indirectly by a user's code, for example
                via the public Dispose() method. In this case, both managed and
                unmanaged resources can be referenced and disposed.  If disposing ==
                false, the method has been called by the runtime from inside the
                object finalizer and this method should not reference other objects;
                in that case only unmanaged resources must be referenced or
                disposed.
              </para>
            </remarks>
            <param name="disposing">
              true if the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using DEFLATE (RFC 1951).
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)">GZipStream.CompressString(string)</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.CompressString(System.String)">ZlibStream.CompressString(string)</seealso>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using DEFLATE.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(string)</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])">GZipStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.CompressBuffer(System.Byte[])">ZlibStream.CompressBuffer(byte[])</seealso>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a single string.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(String)</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])">GZipStream.UncompressString(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.UncompressString(System.Byte[])">ZlibStream.UncompressString(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing DEFLATE-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a byte array.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])">GZipStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">ZlibStream.UncompressBuffer(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing data that has been compressed with DEFLATE.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
             <remarks>
               By tweaking this parameter, you may be able to optimize the compression for
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.GZipStream">
             <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
             <remarks>
            
             <para>
               The <c>GZipStream</c> is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream"/>. It adds GZIP compression or decompression to any
               stream.
             </para>
            
             <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
            
             <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
            
             <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
            
             <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
            
             <para>
               This class is similar to <see cref="T:BestHTTP.Decompression.Zlib.ZlibStream"/> and <see cref="T:BestHTTP.Decompression.Zlib.DeflateStream"/>.
               <c>ZlibStream</c> handles RFC1950-compliant streams.  <see cref="T:BestHTTP.Decompression.Zlib.DeflateStream"/>
               handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
             </para>
            
             </remarks>
            
             <seealso cref="T:BestHTTP.Decompression.Zlib.DeflateStream"/>
             <seealso cref="T:BestHTTP.Decompression.Zlib.ZlibStream"/>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.GZipStream.LastModified">
             <summary>
               The last modified time for the GZIP stream.
             </summary>
            
             <remarks>
               GZIP allows the storage of a last modified time with each GZIP entity.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n > 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n > 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  > 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
             <remarks>
            
             <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
               the stream open.
             </para>
            
             <para>
               The <see cref="T:BestHTTP.Decompression.Zlib.CompressionMode"/> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)"/>.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            
             <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
               leave the stream open.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a single string.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing GZIP-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a byte array.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing data that has been compressed with GZip.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Comment">
             <summary>
               The comment on the GZIP stream.
             </summary>
            
             <remarks>
             <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
            
             <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.FileName">
             <summary>
               The FileName for the GZIP stream.
             </summary>
            
             <remarks>
            
             <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
            
             <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation.
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream.
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s">the message for the exception.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
            
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.Adler">
             <summary>
             Computes an Adler-32 checksum.
             </summary>
             <remarks>
             The Adler checksum is similar to a CRC checksum, but faster to compute, though less
             reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
             is a required part of the "ZLIB" standard.  Applications will almost never need to
             use this class directly.
             </remarks>
            
             <exclude/>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.Adler.Adler32(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calculates the Adler32 checksum.
            </summary>
            <remarks>
              <para>
                This is used within ZLIB.  You probably don't need to use this directly.
              </para>
            </remarks>
            <example>
               To compute an Adler32 checksum on a byte array:
             <code>
               var adler = Adler.Adler32(0, null, 0, 0);
               adler = Adler.Adler32(adler, buffer, index, length);
             </code>
            </example>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.#ctor(BestHTTP.Decompression.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.Inflate(BestHTTP.Decompression.Zlib.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.Deflate(BestHTTP.Decompression.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.SetDeflateParams(BestHTTP.Decompression.Zlib.CompressionLevel,BestHTTP.Decompression.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.ZlibStream">
             <summary>
             Represents a Zlib stream for compression or decompression.
             </summary>
             <remarks>
            
             <para>
             The ZlibStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream"/>.  It adds ZLIB compression or decompression to any
             stream.
             </para>
            
             <para> Using this stream, applications can compress or decompress data via
             stream <c>Read()</c> and <c>Write()</c> operations.  Either compresssion or
             decompression can occur through either reading or writing. The compression
             format used is ZLIB, which is documented in <see href="http://www.ietf.org/rfc/rfc1950.txt">IETF RFC 1950</see>, "ZLIB Compressed
             Data Format Specification version 3.3". This implementation of ZLIB always uses
             DEFLATE as the compression method.  (see <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
             Compressed Data Format Specification version 1.3.") </para>
            
             <para>
             The ZLIB format allows for varying compression methods, window sizes, and dictionaries.
             This implementation always uses the DEFLATE compression method, a preset dictionary,
             and 15 window bits by default.
             </para>
            
             <para>
             This class is similar to <see cref="T:BestHTTP.Decompression.Zlib.DeflateStream"/>, except that it adds the
             RFC1950 header and trailer bytes to a compressed stream when compressing, or expects
             the RFC1950 header and trailer bytes when decompressing.  It is also similar to the
             <see cref="T:BestHTTP.Decompression.Zlib.GZipStream"/>.
             </para>
             </remarks>
             <seealso cref="T:BestHTTP.Decompression.Zlib.DeflateStream"/>
             <seealso cref="T:BestHTTP.Decompression.Zlib.GZipStream"/>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode)">
             <summary>
             Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c>
               will use the default compression level. The "captive" stream will be
               closed when the <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
             This example uses a <c>ZlibStream</c> to compress a file, and writes the
             compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
               The "captive" stream will be closed when the <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
               This example uses a <c>ZlibStream</c> to compress data from a file, and writes the
               compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                     Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the captive stream should be left open after
               Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c> will use
               the default compression level.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter to leave the stream
               open.
             </para>
            
             <para>
             See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">The stream which will be read or written. This is called the
             "captive" stream in other places in this documentation.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain
             open after inflation/deflation.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify
               whether the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive
               stream remain open after the deflation or inflation occurs.  By
               default, after <c>Close()</c> is called on the stream, the captive
               stream is also closed. In some cases this is not desired, for example
               if the stream is a <see cref="T:System.IO.MemoryStream"/> that will be
               re-read after compression.  Specify true for the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ZlibStream to compress the data from a file,
             and store the result into another file. The filestream remains open to allow
             additional data to be written to it.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".zlib"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
            
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            
             <param name="leaveOpen">
             true if the application would like the stream to remain open after
             inflation/deflation.
             </param>
            
             <param name="level">
             A tuning knob to trade speed for effectiveness. This parameter is
             effective only when mode is <c>CompressionMode.Compress</c>.
             </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while reading,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               providing an uncompressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data read will be compressed.  If you wish to
               use the <c>ZlibStream</c> to decompress data while reading, you can create
               a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, providing a
               readable compressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data will be decompressed as it is read.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but
               not both.
             </para>
            
             </remarks>
            
             <param name="buffer">
             The buffer into which the read data should be placed.</param>
            
             <param name="offset">
             the offset within that data array to put the first byte read.</param>
            
             <param name="count">the number of bytes to read.</param>
            
             <returns>the number of bytes read</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
             <summary>
             Calling this method always throws a <see cref="T:System.NotSupportedException"/>.
             </summary>
             <param name="offset">
               The offset to seek to....
               IF THIS METHOD ACTUALLY DID ANYTHING.
             </param>
             <param name="origin">
               The reference specifying how to apply the offset....  IF
               THIS METHOD ACTUALLY DID ANYTHING.
             </param>
            
             <returns>nothing. This method always throws.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while writing,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               and a writable output stream.  Then call <c>Write()</c> on that
               <c>ZlibStream</c>, providing uncompressed data as input.  The data sent to
               the output stream will be the compressed form of the data written.  If you
               wish to use the <c>ZlibStream</c> to decompress data while writing, you
               can create a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that stream,
               providing previously compressed data. The data sent to the output stream
               will be the decompressed form of the data written.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.ZlibStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)"/>
            
             <param name="s">
               A string to compress.  The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.CompressString(System.String)"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
             A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a ZLIB-compressed byte array into a single string.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.CompressString(System.String)"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a ZLIB-compressed byte array into a byte array.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.ZlibStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes. The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotSupportedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:BestHTTP.Extensions.Extensions.AsciiToString(System.Byte[])">
            <summary>
            On WP8 platform there are no ASCII encoding.
            </summary>
        </member>
        <member name="M:BestHTTP.Extensions.Extensions.GetASCIIBytes(System.String)">
            <summary>
            On WP8 platform there are no ASCII encoding.
            </summary>
        </member>
        <member name="M:BestHTTP.Extensions.Extensions.ReadBuffer(System.IO.Stream,System.Byte[])">
            <summary>
            Will fill the entire buffer from the stream.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPConnection">
            <summary>
            Represents and manages a connection to a server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPConnection.ServerAddress">
            <summary>
            The address of the server that this connection is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPConnection.State">
            <summary>
            The state of this connection.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPConnection.IsFree">
            <summary>
            It's true if this connection is available to process a HTTPRequest.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPConnection.CurrentRequest">
            <summary>
            If the State is HTTPConnectionStates.Processing, then it holds a HTTPRequest instance. Otherwise it's null.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPConnection.StartTime">
            <summary>
            When we start to process the current request. It's set after the connection is estabilished.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPConnection.TimedOutStart">
            <summary>
            When this connection timed out.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnection.RetryCauses.None">
            <summary>
            The request processed without any special case.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnection.RetryCauses.Reconnect">
            <summary>
            If the server closed the connection while we sending a request we should reconnect and send the request again. But we will try it once.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnection.RetryCauses.Authenticate">
            <summary>
            We need an another try with Authorization header set.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnection.RetryCauses.ProxyAuthenticate">
            <summary>
            The proxy needs authentication.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPConnectionStates">
            <summary>
            Possible states of a Http Connection.
            The ideal lifecycle of a connection that has KeepAlive is the following: Initial => [Processing => WaitForRecycle => Free] => Closed.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Initial">
            <summary>
            This Connection instance is just created.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Processing">
            <summary>
            This Connection is processing a request
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Redirected">
            <summary>
            The request redirected.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Upgraded">
            <summary>
            The connection is upgraded from http.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.WaitForProtocolShutdown">
            <summary>
            Wait for the upgraded protocol to shut down.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.WaitForRecycle">
            <summary>
            The Connection is finished processing the request, it's waiting now to deliver it's result.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Free">
            <summary>
            The request result's delivered, it's now up to processing again.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.AbortRequested">
            <summary>
            A request from outside of the plugin to abort the connection.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.TimedOut">
            <summary>
            The request is not finished in the given time.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Closed">
            <summary>
            If it's not a KeepAlive connection, or something happend, then we close this connection and remove from the pool.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPManager">
            <summary>
            
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.Connections">
            <summary>
            All connection has a reference in this Dictionary untill it's removed completly.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.ActiveConnections">
            <summary>
            Active connections. These connections all has a request to process.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.FreeConnections">
            <summary>
            Free connections. They can be removed completly after a specified time.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.RecycledConnections">
            <summary>
            Connections that recycled in the Update loop. If they are not used in the same loop to process a request, they will be transferred to the FreeConnections list.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.RequestQueue">
            <summary>
            List of request that have to wait until there is a free connection to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.CanProcessFromQueue">
            <summary>
            Will return with true when there at least one request that can be processed from the RequestQueue.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.GetConnectionWith(BestHTTP.HTTPRequest)">
            <summary>
            Will return the HTTPConnection object that processing the given request.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.GetRootCacheFolder">
            <summary>
            Will return where the various caches should be saved.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.OnUpdate">
            <summary>
            Update function that should be called regularly from a Unity event(Update, LateUpdate). Callbacks are dispatched from this function.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.MaxConnectionPerServer">
            <summary>
            The maximum active tcp connections that the client will maintain to a server. Default value is 4. Minimum value is 1.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.KeepAliveDefaultValue">
            <summary>
            Default value of a http request's IsKeepAlive value. Default value is true. If you make rare request to the server it's should be changed to false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.IsCachingDisabled">
            <summary>
            Set to true, if caching is prohibited.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.MaxConnectionIdleTime">
            <summary>
            How many time must be passed to destroy that connection after a connection finished it's last request. It's default value is two minutes.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.IsCookiesEnabled">
            <summary>
            Set to false to disable all Cookie. It's default value is true.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.CookieJarSize">
            <summary>
            Size of the Cookie Jar in bytes. It's default value is 10485760 (10 MB).
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.EnablePrivateBrowsing">
            <summary>
            If this property is set to true, then new cookies treated as session cookies and these cookies are not saved to disk. It's default value is false;
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.ConnectTimeout">
            <summary>
            Global, default value of the HTTPRequest's ConnectTimeout property. Default value is 20 seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.RequestTimeout">
            <summary>
            Global, default value of the HTTPRequest's Timeout property. Default value is 60 seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.RootCacheFolderProvider">
            <summary>
            By default the plugin will save all cache and cookie data under the path returned by Application.persistentDataPath.
            You can assign a function to this delegate to return a custom root path to define a new path.
            <remarks>This delegate will be called on a non Unity thread!</remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.Proxy">
            <summary>
            The global, default proxy for all HTTPRequests. The HTTPRequest's Proxy still can be changed per-request. Default value is null.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.Heartbeats">
            <summary>
            Heartbeat manager to use less threads in the plugin. The heartbeat updates are called from the OnUpdate function.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.Logger">
            <summary>
            A basic ILogger implementation to be able to log intelligently additional informations about the plugin's internal mechanism.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.DefaultCertificateVerifyer">
            <summary>
            The default ICertificateVerifyer implementation that the plugin will use when the request's UseAlternateSSL property is set to true.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.MaxPathLength">
            <summary>
            On most systems the maximum length of a path is around 255 character. If a cache entity's path is longer than this value it doesn't get cached. There no patform independent API to query the exact value on the current system, but it's 
            exposed here and can be overridden. It's default value is 255.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPMethods">
            <summary>
            Some supported methods described in the rfc: http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Get">
            <summary>
            The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.
            If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the 
            entity in the response and not the source text of the process, unless that text happens to be the output of the process.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Head">
            <summary>
            The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.
            The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request.
            This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself.
            This method is often used for testing hypertext links for validity, accessibility, and recent modification. 
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Post">
            <summary>
            The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line.
            POST is designed to allow a uniform method to cover the following functions:
            <list type="bullet">
                <item><description>Annotation of existing resources;</description></item>
                <item><description>Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;</description></item>
                <item><description>Providing a block of data, such as the result of submitting a form, to a data-handling process;</description></item>
                <item><description>Extending a database through an append operation.</description></item>
            </list>
            The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI. 
            The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, 
            a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database. 
            The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, 
            either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Put">
            <summary>
            The PUT method requests that the enclosed entity be stored under the supplied Request-URI. 
            If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. 
            If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, 
            the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response. 
            If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request. 
            If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem. 
            The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Delete">
            <summary>
            The DELETE method requests that the origin server delete the resource identified by the Request-URI. This method MAY be overridden by human intervention (or other means) on the origin server. 
            The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully. 
            However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location. 
            A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content) 
            if the action has been enacted but the response does not include an entity.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Patch">
            <summary>
            http://tools.ietf.org/html/rfc5789
            The PATCH method requests that a set of changes described in the request entity be applied to the resource identified by the Request-URI.
            The set of changes is represented in a format called a "patchdocument" identified by a media type. If the Request-URI does not point to an existing resource, 
            the server MAY create a new resource, depending on the patch document type (whether it can logically modify a null resource) and permissions, etc.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPRange">
            <summary>
            
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.FirstBytePos">
            <summary>
            The first byte's position that the server sent.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.LastBytePos">
            <summary>
            The last byte's position that the server sent.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.ContentLength">
            <summary>
            Indicates the total length of the full entity-body on the server, -1 if this length is unknown or difficult to determine.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.IsValid">
            <summary>
            
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPRequest">
            <summary>
            
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.MethodNames">
            <summary>
            Cached uppercase values to save some cpu cycles and GC alloc per request.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.UploadChunkSize">
            <summary>
            Size of the internal buffer, and upload progress will be fired when this size of data sent to the wire. It's default value is 1024 bytes.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.OnUploadProgress">
            <summary>
            Called after data sent out to the wire.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.OnProgress">
            <summary>
            Called when new data downloaded from the server.
            The first parameter is the original HTTTPRequest object itself, the secound parameter is the downloaded bytes while the third parameter is the content length.
            <remarks>There are download modes where we can't figure out the exact length of the final content. In these cases we just guarantee that the third parameter will be at least the size of the secound one.</remarks>
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.OnUpgraded">
            <summary>
            Called when the current protocol is upgraded to an other. (HTTP => WebSocket for example)
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.FieldCollector">
            <summary>
            We will collect the fields and values to the FieldCollector through the AddField and AddBinaryData functions.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.FormImpl">
            <summary>
            When the request about to send the request we will create a specialised form implementation(url-encoded, multipart, or the legacy WWWForm based).
            And we will use this instance to create the data that we will send to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddField(System.String,System.String)">
            <summary>
            Add a field with a given string value.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddField(System.String,System.String,System.Text.Encoding)">
            <summary>
            Add a field with a given string value.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddBinaryData(System.String,System.Byte[])">
            <summary>
            Add a field with binary content to the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddBinaryData(System.String,System.Byte[],System.String)">
            <summary>
            Add a field with binary content to the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddBinaryData(System.String,System.Byte[],System.String,System.String)">
            <summary>
            Add a field with binary content to the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetFields(UnityEngine.WWWForm)">
            <summary>
            Set or overwrite the internal form. Remarks: on WP8 it doesn't supported!
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetForm(BestHTTP.Forms.HTTPFormBase)">
            <summary>
            Manually set a HTTP Form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.ClearForm">
            <summary>
            Clears all data from the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SelectFormImplementation">
            <summary>
            Will create the form implementation based on the value of the FormUsage property.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddHeader(System.String,System.String)">
            <summary>
            Adds a header and value pair to the Headers. Use it to add custom headers to the request.
            </summary>
            <example>AddHeader("User-Agent', "FooBar 1.0")</example>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetHeader(System.String,System.String)">
            <summary>
            Removes any previously added values, and sets the given one.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.RemoveHeader(System.String)">
            <summary>
            Removes the specified header. Returns true, if the header found and succesfully removed.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:BestHTTP.HTTPRequest.HasHeader(System.String)">
            <summary>
            Returns true if the given head name is already in the Headers.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.GetFirstHeaderValue(System.String)">
            <summary>
            Returns the first header or null for the given header name.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.GetHeaderValues(System.String)">
            <summary>
            Returns all header values for the given header or null.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetRangeHeader(System.Int32)">
            <summary>
            Sets the Range header to download the content from the given byte position. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35
            </summary>
            <param name="firstBytePos">Start position of the download.</param>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetRangeHeader(System.Int32,System.Int32)">
            <summary>
            Sets the Range header to download the content from the given byte position to the given last position. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35
            </summary>
            <param name="firstBytePos">Start position of the download.</param>
            <param name="lastBytePos">The end position of the download.</param>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SendHeaders(System.IO.BinaryWriter)">
            <summary>
            Writes out the Headers to the stream.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.DumpHeaders">
            <summary>
            Returns a string representation of the headers.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Prepare">
            <summary>
            Called on Unity's main thread just before processing it.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Send">
            <summary>
            Starts processing the request.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Abort">
            <summary>
            Aborts an already estabilished connection, so no further download or upload are done.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Clear">
            <summary>
            Resets the request for a state where switching MethodType is possible.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Uri">
            <summary>
            The original request's Uri.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.MethodType">
            <summary>
            The method that how we want to process our request the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.RawData">
            <summary>
            The raw data to send in a POST request. If it set all other fields that added to this request will be ignored.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadStream">
            <summary>
            The stream that the plugin will use to get the data to send out the server. When this property is set, no forms or the RawData property will be used
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DisposeUploadStream">
            <summary>
            When set to true(it's default value) the plugin will call the UploadStream's Dispose() function when finished uploading the data from it. Default value is true.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UseUploadStreamLength">
            <summary>
            If it's true, the plugin will use the Stream's Length property. Otherwise the plugin will send the data chunked. Default value is true.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.IsKeepAlive">
            <summary>
            Indicates that the connection should be open after the response received. If its true, then the internal tcp connections will be reused if it's possible. Default value is true.
            The default value can be changed in the HTTPManager class. If you make rare request to the server it's should be changed to false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DisableCache">
            <summary>
            With this property caching can be enabled/disabled on a per-request basis.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UseStreaming">
            <summary>
            If it's true, the Callback will be called every time if we can send out at least one fragment.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.StreamFragmentSize">
            <summary>
            Maximum size of a data chunk that we want to receive when streaming is set.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Callback">
            <summary>
            The callback function that will be called when a request is fully processed or when any downloaded fragment is available if UseStreaming is true. Can be null for fire-and-forget requests.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DisableRetry">
            <summary>
            With this option if reading back the server's response fails, the request will fail and any exceptions can be checked through the Exception property. The default value is True for POST requests, otherwise false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.IsRedirected">
            <summary>
            Indicates that the request is redirected. If a request is redirected, the connection that served it will be closed regardless of the value of IsKeepAlive.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.RedirectUri">
            <summary>
            The Uri that the request redirected to.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.CurrentUri">
            <summary>
            If redirected it contains the RedirectUri.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Response">
            <summary>
            The response to the query.
            <remarks>If an exception occured during reading of the response stream or can't connect to the server, this will be null!</remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.ProxyResponse">
            <summary>
            Reponse from the Proxy server. It's null with transparent proxies.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Exception">
            <summary>
            It there is an exception while processing the request or response the Response property will be null, and the Exception will be stored in this property.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Tag">
            <summary>
            Any object can be passed with the request with this property. (eq. it can be identified, etc.)
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Credentials">
            <summary>
            The UserName, Password pair that the plugin will use to authenticate to the remote server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.HasProxy">
            <summary>
            True, if there is a Proxy object.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Proxy">
            <summary>
            A web proxy's properties where the request must pass through.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.MaxRedirects">
            <summary>
            How many redirection supported for this request. The default is int.MaxValue. 0 or a negative value means no redirection supported.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UseAlternateSSL">
            <summary>
            Use Bouncy Castle's code to handle the secure protocol instead of Mono's. You can try to set it true if you receive a "System.Security.Cryptography.CryptographicException: Unsupported hash algorithm" exception.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.IsCookiesEnabled">
            <summary>
            If true cookies will be added to the headers (if any), and parsed from the response. If false, all cookie operations will be ignored. It's default value is HTTPManager's IsCookiesEnabled.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Cookies">
            <summary>
            Cookies that are added to this list will be sent to the server alongside withe the server sent ones. If cookies are disabled only these cookies will be sent.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.FormUsage">
            <summary>
            What form should used. Default to Automatic.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.State">
            <summary>
            Current state of this request.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.RedirectCount">
            <summary>
            How many times redirected.
            </summary>
        </member>
        <member name="E:BestHTTP.HTTPRequest.CustomCertificationValidator">
            <summary>
            Custom validator for an SslStream. This event will receive the original HTTPRequest, an X509Certificate and an X509Chain objects. It must return true if the certificate valid, false otherwise.
            <remarks>It's called in a thread! Not available on Windows Phone!</remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.ConnectTimeout">
            <summary>
            Maximum time we wait to estabilish the connection to the target server. Default value is 20 seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Timeout">
            <summary>
            Maximum time we want to wait to the request to finish after the connection is estabilished. Default value is 60 seconds.
            <remarks>It's disabled for streaming requests! See <see cref="P:BestHTTP.HTTPRequest.EnableTimoutForStreaming"/>.</remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.EnableTimoutForStreaming">
            <summary>
            Set to true to enable Timeouts on streaming request. Default value is false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Priority">
            <summary>
            The priority of the request. Higher priority requests will be picked from the request queue sooner then lower priority ones.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.CustomCertificateVerifyer">
            <summary>
            The ICertificateVerifyer implementation that the plugin will use to verify the server certificates when the request's UseAlternateSSL property is set to true.
            </summary>
        </member>
        <member name="E:BestHTTP.HTTPRequest.OnBeforeRedirection">
            <summary>
            It's called before the plugin will do a new request to the new uri. The return value of this function will control a the redirection: if it's false the redirection is aborted.
            This function is called on a thread other then the main Unity thread!
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Downloaded">
            <summary>
            How many bytes downloaded so far.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DownloadLength">
            <summary>
            The length of the content that we are currently downloading.
            If chunked encoding is used, then it is the size of the sum of all previous chunks plus the current one.
            When no Content-Length present and no chunked encoding is used then its size is the currently downloaded size.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DownloadProgressChanged">
            <summary>
            Set to true when the downloaded bytes are changed, and set to false when the OnProgress event called.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadStreamLength">
            <summary>
            Will return the length of the UploadStream, or -1 if it's not supported.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Uploaded">
            <summary>
            How many bytes are sent to the wire
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadLength">
            <summary>
            How many bytes are expected we are sending. If we are don't know, then it will be -1.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadProgressChanged">
            <summary>
            Set to true when the uploaded bytes are changed, and set to false when the OnUploadProgress event called.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPUpdateDelegator">
            <summary>
            Delegates some U3D calls to the HTTPManager.
            </summary>
        </member>
        <member name="T:BestHTTP.Authentication.AuthenticationTypes">
            <summary>
            Authentication types that supported by BestHTTP.
            The authentication is defined by the server, so the Basic and Digest are not interchangeable. If you don't know what to use, the preferred way is to choose Unknow.
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.AuthenticationTypes.Unknown">
            <summary>
            If the authentication type is not known this will do a challenge turn to receive what methode should be choosen.
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.AuthenticationTypes.Basic">
            <summary>
            The most basic authentication type. It's easy to do, and easy to crack. ;)
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.AuthenticationTypes.Digest">
            <summary>
            
            </summary>
        </member>
        <member name="T:BestHTTP.Authentication.Credentials">
            <summary>
            Hold all information that required to authenticate to a remote server.
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Credentials.#ctor(System.String,System.String)">
            <summary>
            Set up the authentication credentials with the username and password. The Type will be set to Unknown.
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Credentials.#ctor(BestHTTP.Authentication.AuthenticationTypes,System.String,System.String)">
            <summary>
            Set up the authentication credentials with the given authentication type, username and password.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Credentials.Type">
            <summary>
            The type of the Authentication. If you don't know what to use, the preferred way is to choose Unknow.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Credentials.UserName">
            <summary>
            The username to authenticate on the remote server.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Credentials.Password">
            <summary>
            The password to use in the authentication process. The password will be stored only in this class.
            </summary>
        </member>
        <member name="T:BestHTTP.Authentication.Digest">
            <summary>
            Internal class that stores all information that received from a server in a WWW-Authenticate and need to construct a valid Authorization header. Based on rfc 2617 (http://tools.ietf.org/html/rfc2617).
            Used only internally by the plugin.
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Digest.ParseChallange(System.String)">
            <summary>
            Parses a WWW-Authenticate header's value to retrive all information.
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Digest.GenerateResponseHeader(BestHTTP.HTTPRequest,BestHTTP.Authentication.Credentials)">
            <summary>
            Generates a string that can be set to an Authorization header.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Uri">
            <summary>
            The Uri that this Digest is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Realm">
            <summary>
            A string to be displayed to users so they know which username and password to use. 
            This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Stale">
            <summary>
            A flag, indicating that the previous request from the client was rejected because the nonce value was stale. 
            If stale is TRUE (case-insensitive), the client may wish to simply retry the request with a new encrypted response, without  the user for a new username and password. 
            The server should only set stale to TRUE if it receives a request for which the nonce is invalid but with a valid digest for that nonce 
            (indicating that the client knows the correct username/password). 
            If stale is FALSE, or anything other than TRUE, or the stale directive is not present, the username and/or password are invalid, and new values must be obtained.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Nonce">
            <summary>
            A server-specified data string which should be uniquely generated each time a 401 response is made. 
            Specifically, since the string is passed in the header lines as a quoted string, the double-quote character is not allowed.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Opaque">
            <summary>
            A string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space. 
            It is recommended that this string be base64 or data.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Algorithm">
            <summary>
            A string indicating a pair of algorithms used to produce the digest and a checksum. If this is not present it is assumed to be "MD5". 
            If the algorithm is not understood, the challenge should be ignored (and a different one used, if there is more than one).
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.ProtectedUris">
            <summary>
            List of URIs, as specified in RFC XURI, that define the protection space.
            If a URI is an abs_path, it is relative to the canonical root URL (see section 1.2 above) of the server being accessed. 
            An absoluteURI in this list may refer to a different server than the one being accessed.
            The client can use this list to determine the set of URIs for which the same authentication information may be sent: 
            any URI that has a URI in this list as a prefix (after both have been made absolute) may be assumed to be in the same protection space.
            If this directive is omitted or its value is empty, the client should assume that the protection space consists of all URIs on the responding server.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.QualityOfProtections">
            <summary>
            If present, it is a quoted string of one or more tokens indicating the "quality of protection" values supported by the server. 
            The value "auth" indicates authentication. The value "auth-int" indicates authentication with integrity protection.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.NonceCount">
            <summary>
            his MUST be specified if a qop directive is sent (see above), and MUST NOT be specified if the server did not send a qop directive in the WWW-Authenticate header field.
            The nc-value is the hexadecimal count of the number of requests (including the current request) that the client has sent with the nonce value in this request.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.HA1Sess">
            <summary>
            Used to store the last HA1 that can be used in the next header generation when Algorithm is set to "md5-sess".
            </summary>
        </member>
        <member name="T:BestHTTP.Authentication.DigestStore">
            <summary>
            Stores and manages already received digest infos.
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.DigestStore.SupportedAlgorithms">
            <summary>
            Array of algorithms that the plugin supports. It's in the order of priority(first has the highest priority).
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.DigestStore.GetOrCreate(System.Uri)">
            <summary>
            It will retrive or create a new Digest for the given Uri.
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="T:BestHTTP.Extensions.KeyValuePair">
            <summary>
            Used in string parsers. Its Value is optional.
            </summary>
        </member>
        <member name="T:BestHTTP.Extensions.KeyValuePairList">
            <summary>
            Base class for specialized parsers
            </summary>
        </member>
        <member name="T:BestHTTP.Extensions.WWWAuthenticateHeaderParser">
            <summary>
            Used for parsing WWW-Authenticate headers:
            Digest realm="my realm", nonce="4664b327a2963503ba58bbe13ad672c0", qop=auth, opaque="f7e38bdc1c66fce214f9019ffe43117c"
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketFrameReader">
            <summary>
            Represents an incoming WebSocket Frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.Frames.WebSocketFrameReader.Assemble(System.Collections.Generic.List{BestHTTP.WebSocket.Frames.WebSocketFrameReader})">
            <summary>
            Assembles all fragments into a final frame. Call this on the last fragment of a frame.
            </summary>
            <param name="fragments">The list of previously downloaded and parsed fragments of the frame</param>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.IsFinal">
            <summary>
            True if it's a final Frame in a sequence, or the only one.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.Type">
            <summary>
            The type of the Frame.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.HasMask">
            <summary>
            Indicates if there are any mask sent to decode the data.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.Length">
            <summary>
            The length of the Data.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.Mask">
            <summary>
            The sent byte array as a mask to decode the data.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.Data">
            <summary>
            The decoded array of bytes.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.IWebSocketFrameWriter">
            <summary>
            Outgoing Frame's interface.
            The Frame Writers are helper classes to help send various kind of messages to the server.
            Each type should have its own writer.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.Frames.IWebSocketFrameWriter.Get">
            <summary>
            The final array of bytes that will be sent to the server.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.IWebSocketFrameWriter.Type">
            <summary>
            Type of the frame.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketBinaryFrame">
            <summary>
            Denotes a binary frame. The "Payload data" is arbitrary binary data whose interpretation is solely up to the application layer. 
            This is the base class of all other frame writers, as all frame can be represented as a byte array.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketTextFrame">
            <summary>
            The "Payload data" is text data encoded as UTF-8.  Note that a particular text frame might include a partial UTF-8 sequence; however, the whole message MUST contain valid UTF-8. 
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketContinuationFrame">
            <summary>
            A fragmented message's first frame's contain the type of the message(binary or text), all consecutive frame of that message must be a Continuation frame.
            Last of these frame's Fin bit must be 1.
            </summary>
            <example>For a text message sent as three fragments, the first fragment would have an opcode of 0x1 (text) and a FIN bit clear, 
            the second fragment would have an opcode of 0x0 (Continuation) and a FIN bit clear, 
            and the third fragment would have an opcode of 0x0 (Continuation) and a FIN bit that is set.</example>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketPing">
            <summary>
            The Ping frame contains an opcode of 0x9. A Ping frame MAY include "Application data".
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketPong">
            <summary>
            A Pong frame sent in response to a Ping frame must have identical "Application data" as found in the message body of the Ping frame being replied to.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.Frames.WebSocketPong.#ctor(BestHTTP.WebSocket.Frames.WebSocketFrameReader)">
            <summary>
            A Pong frame sent in response to a Ping frame must have identical "Application data" as found in the message body of the Ping frame being replied to.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketClose">
            <summary>
            The Close frame MAY contain a body (the "Application data" portion of the frame) that indicates a reason for closing, 
            such as an endpoint shutting down, an endpoint having received a frame too large, or an endpoint having received a frame that
            does not conform to the format expected by the endpoint.
            As the data is not guaranteed to be human readable, clients MUST NOT show it to end users. 
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnOpen">
            <summary>
            Called when the connection to the WebSocket server is estabilished.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnMessage">
            <summary>
            Called when a new textual message is received from the server.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnBinary">
            <summary>
            Called when a new binary message is received from the server.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnClosed">
            <summary>
            Called when the server is closed.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnError">
            <summary>
            Called when an error is encountered. The Exception parameter may be null.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnIncompleteFrame">
            <summary>
            Called when an incomplete frame received. No attemp will be made to reassemble these fragments internally, and no reference are stored after this event to this frame.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.requestSent">
            <summary>
            Indicates wheter we sent out the connection request to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.webSocket">
            <summary>
            The internal WebSocketResponse object
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.#ctor(System.Uri)">
            <summary>
            Creates a WebSocket instance from the given uri.
            </summary>
            <param name="uri">The uri of the WebSocket server</param>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.#ctor(System.Uri,System.String,System.String)">
            <summary>
            Creates a WebSocket instance from the given uri, protocol and origin.
            </summary>
            <param name="uri">The uri of the WebSocket server</param>
            <param name="origin">Servers that are not intended to process input from any web page but only for certain sites SHOULD verify the |Origin| field is an origin they expect. 
            If the origin indicated is unacceptable to the server, then it SHOULD respond to the WebSocket handshake with a reply containing HTTP 403 Forbidden status code.</param>
            <param name="protocol">The application-level protocol that the client want to use(eg. "chat", "leaderboard", etc.). Can be null or empty string if not used.</param>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Open">
            <summary>
            Start the opening process.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Send(System.String)">
            <summary>
            It will send the given message to the server in one frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Send(System.Byte[])">
            <summary>
            It will send the given data to the server in one frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Send(System.Byte[],System.UInt64,System.UInt64)">
            <summary>
            Will send count bytes from a byte array, starting from offset.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Send(BestHTTP.WebSocket.Frames.IWebSocketFrameWriter)">
            <summary>
            It will send the given frame to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Close">
            <summary>
            It will initiate the closing of the connection to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Close(System.UInt16,System.String)">
            <summary>
            It will initiate the closing of the connection to the server sending the given code and message.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocket.InternalRequest">
            <summary>
            The internal HTTPRequest object.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocket.IsOpen">
            <summary>
            The connection to the WebSocket server is open.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocket.StartPingThread">
            <summary>
            Set to true to start a new thread to send Pings to the WebSocket server
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocket.PingFrequency">
            <summary>
            The delay between two Pings in millisecs. Minimum value is 100, default is 1000.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.OnText">
            <summary>
            Called when a Text message received
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.OnBinary">
            <summary>
            Called when a Binary message received
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.OnIncompleteFrame">
            <summary>
            Called when an incomplete frame received. No attemp will be made to reassemble these fragments.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.OnClosed">
            <summary>
            Called when the connection closed.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.ReceiverThread">
            <summary>
            On this thred we will receive the incoming data
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.closeSent">
            <summary>
            True if we sent out a Close message to the server
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.closed">
            <summary>
            True if this WebSocket connection is closed
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Send(System.String)">
            <summary>
            It will send the given message to the server in one frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Send(System.Byte[])">
            <summary>
            It will send the given data to the server in one frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Send(System.Byte[],System.UInt64,System.UInt64)">
            <summary>
            Will send count bytes from a byte array, starting from offset.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Send(BestHTTP.WebSocket.Frames.IWebSocketFrameWriter)">
            <summary>
            It will send the given frame to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Close">
            <summary>
            It will initiate the closing of the connection to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Close(System.UInt16,System.String)">
            <summary>
            It will initiate the closing of the connection to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.HandleEvents">
            <summary>
            Internal function to send out received messages.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocketResponse.IsClosed">
            <summary>
            Indicates whether the connection to the server is closed or not.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocketResponse.PingFrequnecy">
            <summary>
            On what frequency we have to send a ping to the server.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocketResponse.MaxFragmentSize">
            <summary>
            Maximum size of a fragment's payload data.
            </summary>
        </member>
    </members>
</doc>
